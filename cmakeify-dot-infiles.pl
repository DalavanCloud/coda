#!/usr/bin/perl
#
# Script for generating CMake *.h.in files for CODA.
#
# Usage: ./cmakeify-dot-infiles <infile> <outfile>
#
# (Typical example: ./cmakeify-dot-infiles config.h.in config.h.cmake.in)
#
# This script:
# + Changes #define lines to #cmakedefine lines
# + Performs custom #define substitutions on some lines (this may be refactored
#   down to the CMake level itself in the future.
# + Is a modified version of the CLS perl code for cmakeifying brathll.
#

use strict;
use warnings;
use File::Basename;

my %ConfVars	= (
    PACKAGE             => "\"coda\"",
	PACKAGE_NAME		=> "\"CODA\"",
	PACKAGE_VERSION		=> "\"1.0\"",
	PACKAGE_STRING		=> "\"CODA 1.0\"",
	PACKAGE_TARNAME		=> "\"coda\"",
	PACKAGE_BUGREPORT	=> "\"\"",
    CODA_VERSION     => "\"1.0\"",
    VERSION             => "\"1.0\""
	);


sub CopyFile($$)
{
    local $_;
    my ($Source, $Dest)	= @_;
    my $Model;

    if ($Source !~ m/\.(in|c|h)$/)
    {# Source file is not a model
        print "-- Copying $Source to $Dest\n";
        copy $Source, $Dest or die "Problem copying file: $!\n";
        return;
    }
    $Model	= substr($Source, -3, 3) eq '.in';

    print "-- Expanding $Source into $Dest\n";
    open SRC, "<", $Source or die "Problem opening ".$Source.":  $!\n";
    open DST, ">", $Dest   or die "Problem creating $Dest: $!\n";
    if ($Model)
    {
        print DST "/* $Dest - Generated by $0 from $Source. */\n"
    }
    my $SourceBase	= basename($Source);
  SOURCE_LINE:
    while (<SRC>)
    {
        if ($Model)
        {
            if ($SourceBase eq "Doxyfile.in")
            {
                s/(OUTPUT_DIRECTORY\s*=).*/$1 \@CODA_DOC_DIRECTORY\@/ig and next SOURCE_LINE;
                s/(HTML_OUTPUT\s*=).*/$1 bratll-html\/libbrat/ig and next SOURCE_LINE;
                s/(LATEX_OUTPUT\s*=).*/$1 bratll-latex\/libbrat/ig and next SOURCE_LINE;
                s/\@VERSION\@/\@CODA_VERSION\@/ig;
                s/\@top_builddir\@/\@CODA_SOURCE_DIR\@\/libbrat/ig;
                s/\@top_srcdir\@/\@CODA_SOURCE_DIR\@/ig;
                s/\@srcdir\@/\@CMAKE_CURRENT_SOURCE_DIR\@/ig;
                next SOURCE_LINE;
            }

            if (($SourceBase eq "config.h.in") &&
                m@#endif /\* !defined\(CODA_CONFIG_H\) \*/@)
            {
                $_ = <<'EOF' . $_;
#ifdef WIN32
#include "../win32/config.h"
#endif

EOF
                next SOURCE_LINE;
            }


            if (m/^(\s*)(#undef)\s+(\w+)/)
            {
                if (exists $ConfVars{$3})
                {
                    $_	= "$1#define $3 ".$ConfVars{$3}.$';
                }
                else
                {
                    $_	= "$1#cmakedefine $3 ".'$'."{$3}$'";
                }
                # Move comment of end of line to preceding line
                s/^(.*)(\/\*.*\*\/)/$2\n$1$'/;
#                if (m/(uchar|ssize_t|ptrdiff_t|off_t|size_t)/)
#                {
#                    $_	= "#cmakedefine HAVE_".uc($1).' ${HAVE_'.uc($1)."}\n".
#                    "#if !defined(HAVE_".uc($1).")\n".
#                    "#define $1 @".uc($1)."@\n".
#                    "#endif\n";
#                }
                if (m/define.*HAVE_ALLOCA_H/)
                {
                    $_	.= <<'EOF'

/* Automatically added by "cmakeify-dot-infiles" conversion script */
/* Needed for windows. */
#cmakedefine HAVE_MALLOC_H ${HAVE_MALLOC_H}
#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif

EOF
                }
            }
        }
    }
    continue
    {
        print DST	or die "Problem writing into $Dest: $!\n";
    }
    close SRC;
    close DST
    or die "Problem closing $Dest: $!\n";
}

# main:

$main::infile = undef;
$main::outfile = undef;

args_init(\@ARGV);


# args:
#   1) - ref to @ARGV
# return:
#   undef
# purpose:
#   parse command line.
# effect:
#   modifies @ARGV
sub args_init {

    my( $args ) = @_;

    @$args < 2
    && usage( "Too few args." );

    $main::outfile = pop( @$args );
    $main::infile = pop( @$args );

    (-f $main::infile)
    || usage( "$main::infile: Must be an existing file." );

    CopyFile($main::infile, $main::outfile);
}


sub usage {
    my( $msg ) = @_;
    print "
Usage: $0 <infile> <outfile>
";

    $msg && print "$msg\n\n";
    exit 1;
}
